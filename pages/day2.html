<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jour 2 — Introduction aux API REST | Web Services</title>
  <link rel="stylesheet" href="../styles/styles.css">
  <link rel="stylesheet" href="../styles/day2.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-logo">
        <img src="../assets/logo.jpeg" alt="YNOV Campus" class="logo-img">
        <span class="logo-text">APIs & Microservices</span>
      </div>
      <ul class="nav-menu">
        <li class="nav-item"><a href="../index.html" class="nav-link">Accueil</a></li>
        <li class="nav-item dropdown">
          <a href="#" class="nav-link dropdown-toggle">
            <i class="fas fa-calendar-alt"></i> Journées
            <i class="fas fa-chevron-down"></i>
          </a>
          <div class="dropdown-menu">
            <a href="day1.html" class="dropdown-item">Jour 1 - Théorie</a>
            <a href="day1FilRouge.html" class="dropdown-item">Jour 1 - Fil Rouge</a>
            <a href="day2.html" class="dropdown-item active">Jour 2 - Théorie</a>
            <a href="day2FilRouge.html" class="dropdown-item">Jour 2 - Fil Rouge</a>
            <a href="day3.html" class="dropdown-item">Jour 3 - Théorie</a>
            <a href="day3FilRouge.html" class="dropdown-item">Jour 3 - Fil Rouge</a>
          </div>
        </li>
        <li class="nav-item"><a href="../index.html#projet" class="nav-link">Projet</a></li>
        <li class="nav-item"><a href="#atelier" class="nav-link">Atelier</a></li>
        <li class="nav-item"><a href="../index.html#contact" class="nav-link">Contact</a></li>
      </ul>
      <div class="hamburger">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
      </div>
    </div>
  </nav>

  <!-- Hero -->
  <section class="hero" style="min-height: 60vh;">
    <div class="container">
      <div class="hero-content">
        <div class="hero-text">
          <h1 class="hero-title">Jour 2</h1>
          <h2 class="hero-subtitle">Introduction aux API REST</h2>
          <p class="hero-description">
            Découvrez les 6 contraintes architecturales REST, apprenez à concevoir des APIs élégantes, 
            et maîtrisez l'art de la pagination et du filtrage.
          </p>
          <div class="hero-buttons">
            <a href="day2FilRouge.html" class="btn btn-primary"><i class="fas fa-code"></i>Démarrer l'atelier</a>
            <a href="../index.html#programme" class="btn btn-secondary"><i class="fas fa-arrow-left"></i>Retour au programme</a>
          </div>
        </div>
        <div class="hero-image-container">
          <img src="../assets/webservices.jpg" alt="Web Services" class="hero-image">
        </div>
      </div>
    </div>
  </section>


  <!-- Objectifs -->
  <section class="introduction">
    <div class="container">
      <div class="section-header">
        <h2 class="section-title">Objectifs d'apprentissage</h2>
      </div>
      <div class="intro-grid">
        <div class="intro-card">
          <div class="card-icon"><i class="fas fa-lightbulb"></i></div>
          <h3>Comprendre REST</h3>
          <p>Maîtriser les 6 contraintes architecturales REST et leurs implications pratiques</p>
        </div>
        <div class="intro-card">
          <div class="card-icon"><i class="fas fa-pencil-ruler"></i></div>
          <h3>Design d'API RESTful</h3>
          <p>Concevoir des APIs avec des conventions de nommage et structure cohérentes</p>
        </div>
        <div class="intro-card">
          <div class="card-icon"><i class="fas fa-code"></i></div>
          <h3>Conception de réponses</h3>
          <p>Structurer les réponses JSON, gérer la pagination et les erreurs selon RFC 7807</p>
        </div>
        <div class="intro-card">
          <div class="card-icon"><i class="fas fa-tools"></i></div>
          <h3>Outils et bonnes pratiques</h3>
          <p>Utiliser les outils de développement et appliquer les bonnes pratiques REST</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Contenu de cours approfondi -->
  <section class="programme">
    <div class="container">
      <div class="section-header">
        <h2 class="section-title">Introduction aux API REST — Cours détaillé</h2>
        <p class="section-subtitle">Théorie complète des API REST avec exemples concrets et bonnes pratiques</p>
      </div>

      <!-- Navigation vers Fil Rouge -->
      <div class="navigation-section">
        <div class="nav-buttons">
          <a href="day2FilRouge.html" class="nav-button">
            <i class="fas fa-code"></i> Fil Rouge J2
          </a>
        </div>
      </div>

      <div class="days-container">
        <div class="day-card expanded">
          <div class="day-header">
            <span class="day-number">1</span>
            <span class="day-theme">Principes REST</span>
          </div>
          <div class="day-content">
            <div class="day-morning">
              <h4><i class="fas fa-lightbulb"></i> REST : Une philosophie, pas un protocole</h4>
              <p>Hier, nous avons vu que REST dominait le paysage des APIs modernes. Mais qu'est-ce que REST exactement ? Beaucoup de développeurs pensent que REST signifie simplement "utiliser HTTP avec du JSON". C'est réducteur. REST est une philosophie architecturale complète définie par Roy Fielding dans sa thèse de doctorat en 2000.</p>
              
              <p>L'histoire de cette thèse est intéressante. Fielding était l'un des principaux auteurs de la spécification HTTP/1.1. Il observait comment le web évoluait et comment les développeurs utilisaient (et abusaient) du protocole HTTP. Il s'est demandé : quels sont les principes architecturaux qui font que le web fonctionne si bien à si grande échelle ? Sa réponse : REST (REpresentational State Transfer).</p>
              
              <p>Le terme peut sembler abstrait, mais décomposons-le. <strong>Representational</strong> signifie que vous manipulez des représentations de ressources, pas les ressources elles-mêmes. Quand vous faites GET /users/123, vous ne récupérez pas l'utilisateur en tant qu'entité réelle, vous récupérez une représentation de cet utilisateur (probablement en JSON). <strong>State Transfer</strong> signifie que chaque requête transfère l'état nécessaire pour la traiter. Le serveur ne garde pas de mémoire des requêtes précédentes.</p>

              <h4 class="mt-5"><i class="fas fa-cogs"></i> Les 6 contraintes architecturales REST</h4>
              <p>REST n'est pas une spécification rigide avec des règles à suivre à la lettre. Ce sont des contraintes architecturales, des principes directeurs. Une API peut être "plus ou moins RESTful" selon combien de ces contraintes elle respecte.</p>

              <h5 class="mt-5">Contrainte 1 : Architecture Client-Serveur</h5>
              <p>Nous avons déjà vu ce principe hier. Le client et le serveur sont séparés, avec des responsabilités distinctes. Le client gère l'interface utilisateur et l'expérience utilisateur. Le serveur gère les données, la logique métier, et la persistance. Cette séparation permet aux deux d'évoluer indépendamment.</p>
              
              <p>Imaginons une banque qui a une application mobile pour ses clients. Le jour où elle décide de refaire complètement l'interface mobile avec un nouveau design, elle n'a pas besoin de toucher au serveur. Inversement, si elle migre sa base de données de MySQL à PostgreSQL, l'application mobile continue de fonctionner sans changement.</p>

              <h5 class="mt-5">Contrainte 2 : Stateless (Sans état)</h5>
              <p>C'est probablement la contrainte la plus importante et la plus mal comprise. Stateless signifie que chaque requête du client vers le serveur doit contenir toutes les informations nécessaires pour comprendre et traiter cette requête. Le serveur ne stocke aucun contexte de session côté serveur entre deux requêtes.</p>
              
              <p>Prenons un exemple concret. Imaginons un site de e-commerce traditionnel non-RESTful des années 2000. Vous vous connectez, le serveur crée une session et stocke votre ID utilisateur en mémoire avec un cookie de session. Vous naviguez, ajoutez des articles au panier (stocké en mémoire serveur), puis vous passez commande. Tout fonctionne tant que vous parlez toujours au même serveur. Mais si vous avez 10 serveurs derrière un load balancer et que votre deuxième requête arrive sur un serveur différent, celui-ci ne sait pas qui vous êtes. Solution classique : sticky sessions, où le load balancer vous colle toujours au même serveur. Mais ça complexifie la scalabilité.</p>
              
              <p><strong>Approche REST :</strong> chaque requête contient un token d'authentification (comme un JWT). Le serveur n'a aucune session en mémoire. Vous faites GET /cart avec votre token, le serveur décode le token, voit que vous êtes l'utilisateur 123, va chercher votre panier en base de données, et vous le renvoie. Peu importe quel serveur traite la requête, le résultat sera le même. Scaling horizontal trivial.</p>
              
              <p>Cette contrainte a un coût : chaque requête est légèrement plus grosse (il faut envoyer le token). Mais les bénéfices en scalabilité et en simplicité sont énormes. C'est pour ça que toutes les grandes plateformes (Google, Facebook, Amazon) utilisent cette approche.</p>

              <h5 class="mt-5">Contrainte 3 : Cacheable</h5>
              <p>Les réponses du serveur doivent explicitement se définir comme cacheable ou non-cacheable. Quand une réponse est cacheable, le client (ou un proxy intermédiaire comme un CDN) peut réutiliser cette réponse pour des requêtes futures identiques, sans re-contacter le serveur.</p>
              
              <p>Imaginons un site de news. L'article que vous lisez maintenant ne va probablement pas changer dans les 5 prochaines minutes. Le serveur peut renvoyer cet article avec un header Cache-Control: max-age=300 (300 secondes = 5 minutes). Votre navigateur stocke cet article en cache local. Si vous actualisez la page dans les 5 minutes, le navigateur utilise sa copie locale sans faire de requête réseau. Résultat : page qui se charge instantanément, pas de charge sur le serveur.</p>
              
              <p>Les codes de statut HTTP ont été conçus pour supporter le caching. Rappelez-vous le 304 Not Modified que nous avons vu hier : le client demande "j'ai cette ressource datée du 15 octobre, est-elle toujours valide ?", le serveur répond "oui" avec un 304 et aucun body. Économie massive de bande passante.</p>

              <h5 class="mt-5">Contrainte 4 : Interface uniforme</h5>
              <p>C'est le cœur de REST. L'interface entre le client et le serveur doit être uniforme, standardisée. Cette contrainte se décompose en quatre sous-principes.</p>
              
              <p><strong>Identification des ressources :</strong> Chaque ressource est identifiée par une URI unique. /users/123 identifie l'utilisateur 123. /orders/456 identifie la commande 456. Cette URI est stable : elle ne change pas même si la représentation de la ressource change.</p>
              
              <p><strong>Manipulation via représentations :</strong> Quand un client détient une représentation d'une ressource avec suffisamment de métadonnées, il a assez d'informations pour modifier ou supprimer cette ressource. Si vous faites GET /users/123 et que vous récupérez l'utilisateur en JSON, vous avez tout ce qu'il faut pour faire ensuite PUT /users/123 avec les modifications.</p>
              
              <p><strong>Messages auto-descriptifs :</strong> Chaque message (requête ou réponse) contient assez d'informations pour décrire comment traiter ce message. Le header Content-Type: application/json dit au destinataire "ce body est du JSON, parse-le comme tel". Le code de statut dit "voilà ce qui s'est passé". Les headers Cache-Control disent "voilà comment cacher cette réponse".</p>
              
              <p><strong>HATEOAS (Hypermedia As The Engine Of Application State) :</strong> C'est le principe le plus avancé et le moins implémenté. L'idée est que les réponses contiennent des liens vers les actions possibles suivantes. Nous verrons ça en détail dans la partie 3.</p>

              <h5 class="mt-5">Contrainte 5 : Système en couches</h5>
              <p>Le client ne peut pas savoir s'il est connecté directement au serveur final ou à un intermédiaire. Vous pourriez avoir une architecture comme : Client → CDN → Load Balancer → API Gateway → Microservice → Database. Du point de vue du client, il parle à une seule entité.</p>
              
              <p>Cette contrainte permet d'ajouter des couches intermédiaires (caching, sécurité, load balancing) de manière transparente. Imaginons que votre API devient victime de son succès et reçoit trop de trafic. Vous pouvez ajouter un CDN Cloudflare devant sans changer une ligne de code côté client. Le client continue de faire ses requêtes, mais maintenant Cloudflare cache les réponses et absorbe 90% du trafic.</p>

              <h5 class="mt-5">Contrainte 6 : Code on demand (optionnel)</h5>
              <p>C'est la seule contrainte optionnelle. Le serveur peut étendre les fonctionnalités du client en envoyant du code exécutable (JavaScript, applets Java à l'époque...). C'est exactement ce que font les applications web modernes : le serveur envoie du JavaScript que le navigateur exécute.</p>
              
              <p>Cette contrainte est rarement mentionnée dans le contexte des APIs REST car elle est peu utilisée pour les APIs pures (qui renvoient des données, pas du code). Mais elle fait partie de la définition originale de REST.</p>

              <h4 class="mt-5"><i class="fas fa-balance-scale"></i> Stateless vs Stateful : un débat pragmatique</h4>
              <p>Le principe stateless est magnifique en théorie, mais la réalité est plus nuancée. Certaines applications ont vraiment besoin d'état. Imaginons une application de vidéoconférence en temps réel. Vous avez une connexion WebSocket ouverte avec le serveur pendant toute la durée de l'appel. C'est intrinsèquement stateful. Le serveur maintient l'état de votre connexion, sait qui est dans la salle, qui parle, etc.</p>
              
              <p>La solution pragmatique : être stateless pour les opérations CRUD standard (créer, lire, modifier, supprimer des ressources), et utiliser des mécanismes stateful (WebSockets, Server-Sent Events) quand c'est vraiment nécessaire pour des fonctionnalités temps réel. Vous pouvez même avoir une API REST stateless pour la gestion des utilisateurs et des salles, et des WebSockets stateful pour la communication temps réel pendant l'appel.</p>

              <h4 class="mt-5"><i class="fas fa-database"></i> Ressources et URIs : penser en termes de "choses"</h4>
              <p>REST est centré sur les ressources. Une ressource est n'importe quelle information qui peut être nommée : un utilisateur, un document, une image, un service temporel (la météo actuelle), une collection d'autres ressources, etc.</p>
              
              <p>La clé est de penser en termes de "choses" (noms) plutôt qu'en termes d'"actions" (verbes). Votre API expose des ressources que les clients peuvent manipuler avec les verbes HTTP standard.</p>

              <div class="highlight-box">
                <h6>🎯 Exemples de design</h6>
                <div class="comparison-examples">
                  <div class="bad-example">
                    <h6>❌ Mauvais design (orienté actions)</h6>
                    <pre><code class="text">POST /createUser
POST /deleteUser?id=123
GET /getUserById?id=123
POST /updateUserEmail</code></pre>
                  </div>
                  <div class="good-example">
                    <h6>✅ Bon design (orienté ressources)</h6>
                    <pre><code class="text">POST /users          (créer)
DELETE /users/123    (supprimer)
GET /users/123       (lire)
PATCH /users/123     (modifier)</code></pre>
                  </div>
                </div>
                <p>Dans le bon design, la ressource est /users et /users/123. Les actions sont exprimées par les verbes HTTP. C'est plus propre, plus cohérent, plus intuitif.</p>
              </div>
            </div>
          </div>
        </div>

        <div class="day-card expanded">
          <div class="day-header">
            <span class="day-number">2</span>
            <span class="day-theme">Design d'API RESTful</span>
          </div>
          <div class="day-content">
            <div class="day-morning">
              <h4><i class="fas fa-pencil-ruler"></i> Conventions de nommage des endpoints</h4>
              <p>Le nommage est crucial. Une bonne API doit être intuitive. Un développeur devrait pouvoir deviner les endpoints sans lire la documentation. Voici les conventions établies.</p>

              <h5 class="mt-5">Utiliser des noms au pluriel</h5>
              <p>Toujours utiliser le pluriel pour les collections, même quand on manipule une seule ressource.</p>
              
              <div class="code-comparison">
                <div class="good">
                  <h6>✅ Bon</h6>
                  <pre><code class="text">GET /users/123
GET /products</code></pre>
                </div>
                <div class="bad">
                  <h6>❌ Mauvais</h6>
                  <pre><code class="text">GET /user/123
GET /product</code></pre>
                </div>
              </div>
              
              <p>Pourquoi ? Cohérence. Si /users liste tous les utilisateurs et /users/123 récupère un utilisateur spécifique, c'est logique. Si vous mélangez /user/123 et /users, c'est confus.</p>
              
              <p><strong>Exception rare :</strong> les singletons. Si votre API a une ressource unique comme /profile (le profil de l'utilisateur connecté), vous pouvez utiliser le singulier car il n'y a jamais de collection.</p>

              <h5 class="mt-5">Utiliser des noms, pas des verbes</h5>
              <div class="code-comparison">
                <div class="good">
                  <h6>✅ Bon</h6>
                  <pre><code class="text">GET /users
POST /orders
DELETE /products/123</code></pre>
                </div>
                <div class="bad">
                  <h6>❌ Mauvais</h6>
                  <pre><code class="text">GET /getUsers
POST /createOrder
DELETE /deleteProduct/123</code></pre>
                </div>
              </div>
              
              <p>Le verbe est déjà dans la méthode HTTP. Pas besoin de le répéter dans l'URL.</p>
              
              <p><strong>Exception :</strong> les actions qui ne correspondent pas à CRUD. Imaginons une action "réinitialiser le mot de passe". Ce n'est ni un create, ni un update au sens strict. Vous pouvez créer un endpoint POST /users/123/reset-password. Le verbe est accepté quand l'action ne peut pas être modélisée simplement comme une opération CRUD.</p>

              <h5 class="mt-5">Utiliser kebab-case pour les URLs</h5>
              <div class="code-comparison">
                <div class="good">
                  <h6>✅ Bon</h6>
                  <pre><code class="text">/users/123/order-history</code></pre>
                </div>
                <div class="bad">
                  <h6>❌ Mauvais</h6>
                  <pre><code class="text">/users/123/orderHistory
/users/123/order_history</code></pre>
                </div>
              </div>
              
              <p>Les URLs sont case-insensitive techniquement, mais par convention on utilise kebab-case (tirets) en minuscules. C'est plus lisible dans les URLs.</p>

              <h4 class="mt-5"><i class="fas fa-sitemap"></i> Hiérarchie et ressources imbriquées</h4>
              <p>Quand une ressource appartient clairement à une autre, utilisez l'imbrication.</p>
              
              <div class="code-example">
                <pre><code class="text">GET /users/123/orders          # Les commandes de l'utilisateur 123
GET /orders/456/items          # Les articles de la commande 456
GET /posts/789/comments        # Les commentaires du post 789</code></pre>
              </div>
              
              <p>Mais attention à ne pas trop imbriquer. Maximum 2-3 niveaux. Si vous vous retrouvez avec /users/123/orders/456/items/789/options/012, c'est ingérable. Dans ce cas, mettez les ressources au même niveau et utilisez des query parameters pour filtrer.</p>
              
              <div class="code-comparison">
                <div class="good">
                  <h6>✅ Bon</h6>
                  <code>GET /order-items/789?order_id=456</code>
                </div>
                <div class="bad">
                  <h6>❌ Mauvais</h6>
                  <code>GET /users/123/orders/456/items/789</code>
                </div>
              </div>

              <h4 class="mt-5"><i class="fas fa-route"></i> Structure des URLs : clarté et cohérence</h4>
              <div class="pattern-box">
                <h5 class="mt-5">Pattern de base pour les collections</h5>
                <pre><code class="text">GET    /resources              # Liste toutes les ressources
POST   /resources              # Crée une nouvelle ressource
GET    /resources/{id}         # Récupère une ressource spécifique
PUT    /resources/{id}         # Remplace complètement la ressource
PATCH  /resources/{id}         # Modifie partiellement la ressource
DELETE /resources/{id}         # Supprime la ressource</code></pre>
              </div>
              
              <p>C'est le pattern fondamental. Chaque collection dans votre API devrait suivre ce pattern.</p>

              <h5 class="mt-5">Gestion des actions complexes</h5>
              <p>Parfois, vous avez besoin d'actions qui ne rentrent pas dans le moule CRUD. Plusieurs approches existent.</p>
              
              <p><strong>Approche 1 : Sous-ressource</strong><br>
              Au lieu de voir une action comme un verbe, voyez-la comme une sous-ressource.</p>
              
              <div class="code-example">
                <pre><code class="text">POST /orders/123/payment        # Payer une commande
POST /users/456/activation      # Activer un utilisateur
POST /articles/789/publication  # Publier un article</code></pre>
              </div>
              
              <p>Ici, payment, activation, publication sont modélisés comme des sous-ressources. Vous créez un paiement, vous créez une activation, vous créez une publication.</p>
              
              <p><strong>Approche 2 : Verbe explicite (dernier recours)</strong><br>
              Quand vraiment l'action ne peut pas être modélisée comme une ressource :</p>
              
              <div class="code-example">
                <pre><code class="text">POST /users/123/send-reset-email
POST /cart/calculate-shipping
POST /reports/generate</code></pre>
              </div>
              
              <p>C'est moins "pur" REST, mais c'est pragmatique. Mieux vaut une API claire avec quelques verbes qu'une API alambiquée qui force tout dans le moule CRUD.</p>

              <h4 class="mt-5"><i class="fas fa-link"></i> Relations entre ressources</h4>
              <p>Les ressources sont rarement isolées. Un utilisateur a des commandes. Une commande a des articles. Un article appartient à une catégorie. Comment modéliser ces relations ?</p>

              <h5 class="mt-5">Relation one-to-many</h5>
              <p>Un utilisateur a plusieurs commandes. Deux approches principales.</p>
              
              <div class="relation-examples">
                <div class="relation-approach">
                  <h6>Approche 1 : Endpoint imbriqué</h6>
                  <code>GET /users/123/orders</code>
                  <p><strong>Avantages :</strong> Clair, explicite.</p>
                  <p><strong>Inconvénients :</strong> Si un même ordre peut appartenir à plusieurs utilisateurs (ex: commande groupée), ça devient compliqué.</p>
                </div>
                <div class="relation-approach">
                  <h6>Approche 2 : Query parameter</h6>
                  <code>GET /orders?user_id=123</code>
                  <p><strong>Avantages :</strong> Flexible, permet des filtres multiples.</p>
                  <p><strong>Inconvénients :</strong> Moins explicite sur la relation.</p>
                </div>
              </div>
              
              <p>Choisissez l'approche 1 pour les relations fortes et évidentes. Choisissez l'approche 2 pour plus de flexibilité.</p>

              <h5 class="mt-5">Relation many-to-many</h5>
              <p>Un étudiant suit plusieurs cours. Un cours a plusieurs étudiants. Comment gérer ça ?</p>
              
              <div class="relation-examples">
                <div class="relation-approach">
                  <h6>Option 1 : Sous-ressource dans les deux sens</h6>
                  <pre><code class="text">GET /students/123/courses       # Les cours de l'étudiant 123
GET /courses/456/students       # Les étudiants du cours 456</code></pre>
                </div>
                <div class="relation-approach">
                  <h6>Option 2 : Ressource intermédiaire</h6>
                  <pre><code class="text">GET /enrollments?student_id=123    # Toutes les inscriptions de l'étudiant 123
GET /enrollments?course_id=456     # Toutes les inscriptions au cours 456
POST /enrollments                  # Créer une nouvelle inscription</code></pre>
                </div>
              </div>
              
              <p>Si la relation elle-même a des attributs (ex: date d'inscription, note), créez une ressource dédiée. Un enrollment contient student_id, course_id, enrollment_date, grade, etc.</p>

              <h5 class="mt-5">Inclusion de ressources liées</h5>
              <p>Parfois, le client veut la ressource principale ET les ressources liées en une seule requête. Utilisez un query parameter include ou expand.</p>
              
              <div class="code-example">
                <pre><code class="text">GET /users/123?include=orders,profile</code></pre>
              </div>
              
              <p>Réponse :</p>
              <div class="json-example">
                <pre><code>{
  "id": 123,
  "name": "Marie Dubois",
  "orders": [
    {"id": 1, "total": 99.99},
    {"id": 2, "total": 149.99}
  ],
  "profile": {
    "bio": "...",
    "avatar": "..."
  }
}</code></pre>
              </div>
              
              <p>C'est pratique pour réduire le nombre de requêtes, mais attention : ne récupérez que ce qui est nécessaire. Si vous incluez trop de données, les performances se dégradent.</p>

              <h4 class="mt-5"><i class="fas fa-tools"></i> Utilisation appropriée des méthodes HTTP</h4>
              <p>Nous avons vu les méthodes hier, mais insistons sur quelques cas d'usage spécifiques dans le contexte REST.</p>

              <h5 class="mt-5">POST vs PUT : une source de confusion</h5>
              <p>Règle simple :</p>
              <ul>
                <li><strong>POST</strong> pour créer une ressource quand le serveur génère l'ID</li>
                <li><strong>PUT</strong> pour créer ou remplacer une ressource quand le client fournit l'ID</li>
              </ul>
              
              <p><strong>Cas classique :</strong> création d'utilisateur.</p>
              
              <div class="code-example">
                <pre><code class="text">POST /users
Body: {"name": "Marie", "email": "marie@example.com"}

Réponse 201 Created:
Location: /users/550e8400-e29b-41d4-a716-446655440000
Body: {"id": "550e8400...", "name": "Marie", ...}</code></pre>
              </div>
              
              <p>Le serveur a généré l'ID (UUID). On utilise POST.</p>
              
              <p><strong>Cas rare :</strong> création avec ID fourni par le client.</p>
              
              <div class="code-example">
                <pre><code class="text">PUT /users/marie-dubois
Body: {"name": "Marie", "email": "marie@example.com"}</code></pre>
              </div>
              
              <p>Le client choisit l'ID (ici marie-dubois comme username). On utilise PUT. Si la ressource existe déjà, elle est remplacée (idempotence de PUT).</p>

              <h5 class="mt-5">PATCH : subtilités</h5>
              <p>PATCH modifie partiellement. Mais comment spécifier exactement quoi modifier ? Deux approches.</p>
              
              <p><strong>Approche 1 : Merge patch (simple)</strong><br>
              Vous envoyez uniquement les champs à modifier.</p>
              
              <div class="code-example">
                <pre><code class="text">PATCH /users/123
Body: {"email": "new-email@example.com"}</code></pre>
              </div>
              
              <p>Le serveur merge ce JSON avec la ressource existante. Simple, mais limité : vous ne pouvez pas supprimer un champ (mettre à null), vous ne pouvez pas modifier des éléments dans un tableau précisément.</p>
              
              <p><strong>Approche 2 : JSON Patch (puissant)</strong><br>
              Format standardisé (RFC 6902) qui permet des opérations précises.</p>
              
              <div class="code-example">
                <pre><code class="text">PATCH /users/123
Content-Type: application/json-patch+json
Body:
[
  {"op": "replace", "path": "/email", "value": "new@example.com"},
  {"op": "add", "path": "/roles/-", "value": "admin"},
  {"op": "remove", "path": "/temporary_field"}
]</code></pre>
              </div>
              
              <p>Opérations : add, remove, replace, move, copy, test. Très puissant, mais plus complexe.</p>
              
              <p>Pour la plupart des APIs, le merge patch simple suffit. Utilisez JSON Patch pour des cas avancés.</p>
            </div>
          </div>
        </div>

        <div class="day-card expanded">
          <div class="day-header">
            <span class="day-number">3</span>
            <span class="day-theme">Conception de réponses API</span>
          </div>
          <div class="day-content">
            <div class="day-morning">
              <h4><i class="fas fa-code"></i> Structure des réponses JSON</h4>
              <p>Une réponse API bien structurée facilite la vie des développeurs. Établissons des conventions.</p>

              <h5 class="mt-5">Réponse pour une ressource unique</h5>
              <div class="json-example">
                <pre><code>{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Marie Dubois",
  "email": "marie@example.com",
  "created_at": "2025-10-24T14:30:00Z",
  "updated_at": "2025-10-25T09:15:00Z"
}</code></pre>
              </div>
              
              <p>Simple, direct. Le body est directement l'objet.</p>

              <h5 class="mt-5">Réponse pour une collection</h5>
              <p>Ne renvoyez JAMAIS un tableau nu au top-level. Enveloppez toujours dans un objet.</p>
              
              <div class="json-comparison">
                <div class="bad-json">
                  <h6>❌ Mauvais :</h6>
                  <pre><code>[
  {"id": 1, "name": "Product A"},
  {"id": 2, "name": "Product B"}
]</code></pre>
                </div>
                <div class="good-json">
                  <h6>✅ Bon :</h6>
                  <pre><code>{
  "data": [
    {"id": 1, "name": "Product A"},
    {"id": 2, "name": "Product B"}
  ],
  "meta": {
    "total": 156,
    "page": 1,
    "per_page": 20
  }
}</code></pre>
                </div>
              </div>
              
              <p>Pourquoi ? Flexibilité future. Si demain vous voulez ajouter des métadonnées (pagination, statistiques, etc.), vous pouvez. Avec un tableau nu, vous cassez la compatibilité.</p>

              <h5 class="mt-5">Métadonnées utiles</h5>
              <div class="json-example">
                <pre><code>{
  "data": [...],
  "meta": {
    "total": 156,          // Nombre total d'éléments
    "count": 20,           // Nombre d'éléments dans cette page
    "page": 1,             // Page actuelle
    "per_page": 20,        // Éléments par page
    "total_pages": 8       // Nombre total de pages
  },
  "links": {
    "self": "/products?page=1",
    "next": "/products?page=2",
    "last": "/products?page=8"
  }
}</code></pre>
              </div>
              
              <p>Ces métadonnées permettent au client de construire une pagination UI facilement.</p>

              <h4 class="mt-5"><i class="fas fa-list-ol"></i> Pagination : gérer les grandes collections</h4>
              <p>Renvoyer 10,000 produits en une seule réponse, c'est inacceptable. Temps de réponse long, consommation mémoire excessive, mauvaise UX. La pagination est essentielle.</p>

              <h5 class="mt-5">Pagination offset-based (classique)</h5>
              <div class="code-example">
                <pre><code class="text">GET /products?page=1&per_page=20
GET /products?offset=40&limit=20</code></pre>
              </div>
              
              <p>Deux variantes. Première : numéro de page + taille de page. Deuxième : offset (nombre d'éléments à sauter) + limit (nombre à récupérer).</p>
              
              <p><strong>Avantages :</strong> Simple, permet de sauter à n'importe quelle page directement.</p>
              <p><strong>Inconvénients :</strong> Performance qui se dégrade sur les grandes tables (offset 10000 est lent en SQL), problèmes si des éléments sont ajoutés/supprimés pendant la pagination.</p>
              
              <p>Imaginons que vous consultez la page 1 (éléments 1-20). Puis 100 nouveaux produits sont ajoutés en tête de liste. Quand vous demandez la page 2, vous obtenez des éléments que vous avez déjà vus sur la page 1. Problème de cohérence.</p>

              <h5 class="mt-5">Pagination cursor-based (moderne)</h5>
              <div class="code-example">
                <code>GET /products?cursor=eyJpZCI6MTIzfQ==&limit=20</code>
              </div>
              
              <p>Le cursor est un pointeur opaque (généralement encodé en base64) qui identifie où vous en êtes. Le serveur renvoie le cursor du prochain batch.</p>
              
              <div class="json-example">
                <pre><code>{
  "data": [...],
  "meta": {
    "next_cursor": "eyJpZCI6MTQzfQ==",
    "has_more": true
  }
}</code></pre>
              </div>
              
              <p><strong>Avantages :</strong> Performance constante quelle que soit la position, cohérence même si des données sont ajoutées/supprimées.</p>
              <p><strong>Inconvénients :</strong> Ne permet pas de sauter directement à la page 5, plus complexe à implémenter.</p>
              
              <p>Utilisez offset-based pour des cas simples (backoffice admin, recherches ponctuelles). Utilisez cursor-based pour des feeds infinis (réseaux sociaux, messagerie, applications temps réel).</p>

              <h5 class="mt-5">Limites raisonnables</h5>
              <p>Imposez des limites. Ne laissez pas le client demander ?limit=1000000.</p>
              
              <div class="code-example">
                <code>per_page = min(request.get('per_page', 20), 100)  # Max 100 par page</code>
              </div>
              
              <p>Si le client demande 1000, clamp à 100 et documentez cette limite.</p>

              <h4 class="mt-5"><i class="fas fa-filter"></i> Filtrage et tri</h4>
              <p>Les clients ont souvent besoin de filtrer et trier les collections.</p>

              <h5 class="mt-5">Filtrage basique</h5>
              <p>Utilisez des query parameters.</p>
              
              <div class="code-example">
                <pre><code class="text">GET /products?category=electronics
GET /products?min_price=100&max_price=500
GET /products?in_stock=true
GET /users?status=active&role=admin</code></pre>
              </div>
              
              <p>Convention : le nom du query parameter correspond au nom du champ. Simple et intuitif.</p>

              <h5 class="mt-5">Filtrage avancé</h5>
              <p>Pour des filtres complexes, utilisez une syntaxe structurée.</p>
              
              <div class="code-example">
                <code>GET /products?filter[category]=electronics&filter[price][gte]=100&filter[price][lte]=500</code>
              </div>
              
              <p>gte = greater than or equal, lte = less than or equal. Cette syntaxe permet des filtres riches sans ambiguïté.</p>

              <h5 class="mt-5">Recherche textuelle</h5>
              <div class="code-example">
                <pre><code class="text">GET /products?search=laptop
GET /users?q=marie</code></pre>
              </div>
              
              <p>search ou q pour une recherche full-text. Le serveur cherche dans plusieurs champs (nom, description, tags...).</p>

              <h5 class="mt-5">Tri</h5>
              <div class="code-example">
                <pre><code class="text">GET /products?sort=price            # Tri ascendant par prix
GET /products?sort=-price           # Tri descendant par prix (le - indique desc)
GET /products?sort=category,price   # Tri multiple : par catégorie puis prix</code></pre>
              </div>
              
              <p>Convention : - préfixe pour descendant, , pour séparer plusieurs critères.</p>

              <h4 class="mt-5"><i class="fas fa-exclamation-triangle"></i> Gestion des erreurs : RFC 7807 Problem Details</h4>
              <p>Hier, nous avons vu les codes de statut HTTP. Mais le code seul ne suffit pas. Le client a besoin de détails : qu'est-ce qui a échoué exactement ? Comment corriger ?</p>
              
              <p>Il existe un standard RFC 7807 "Problem Details for HTTP APIs" qui définit un format JSON pour les erreurs.</p>

              <h5 class="mt-5">Format RFC 7807</h5>
              <div class="json-example">
                <pre><code>{
  "type": "https://api.example.com/errors/validation-error",
  "title": "Validation Failed",
  "status": 422,
  "detail": "The email address is already in use by another account.",
  "instance": "/users",
  "correlation_id": "550e8400-e29b-41d4-a716-446655440000",
  "invalid_fields": [
    {
      "field": "email",
      "message": "Email already exists"
    }
  ]
}</code></pre>
              </div>
              
              <p>Décomposons :</p>
              <ul>
                <li><strong>type :</strong> URI qui identifie le type d'erreur. Idéalement, cette URI pointe vers une documentation.</li>
                <li><strong>title :</strong> Titre human-readable du problème. Générique pour ce type d'erreur.</li>
                <li><strong>status :</strong> Le code de statut HTTP (répété pour commodité).</li>
                <li><strong>detail :</strong> Explication spécifique de cette instance du problème.</li>
                <li><strong>instance :</strong> URI de la requête qui a causé l'erreur.</li>
                <li><strong>correlation_id :</strong> ID unique pour tracer cette erreur dans vos logs (crucial pour le debugging).</li>
                <li><strong>Champs custom :</strong> Vous pouvez ajouter des champs supplémentaires comme invalid_fields.</li>
              </ul>

              <h5 class="mt-5">Content-Type</h5>
              <p>Important : utilisez Content-Type: application/problem+json pour les erreurs RFC 7807, pas application/json. Ça permet au client de savoir qu'il reçoit une erreur structurée.</p>

              <h5 class="mt-5">Exemples d'erreurs courantes</h5>
              
              <div class="error-example">
                <h6>400 Bad Request - JSON invalide</h6>
                <pre><code>{
  "type": "https://api.example.com/errors/invalid-json",
  "title": "Invalid JSON",
  "status": 400,
  "detail": "Unexpected token < in JSON at position 0",
  "instance": "/users",
  "correlation_id": "123e4567-e89b-12d3-a456-426614174000"
}</code></pre>
              </div>
              
              <div class="error-example">
                <h6>401 Unauthorized - Token manquant</h6>
                <pre><code>{
  "type": "https://api.example.com/errors/unauthorized",
  "title": "Unauthorized",
  "status": 401,
  "detail": "No authentication token provided. Please include an Authorization header.",
  "instance": "/users/123",
  "correlation_id": "223e4567-e89b-12d3-a456-426614174000"
}</code></pre>
              </div>
              
              <div class="error-example">
                <h6>403 Forbidden - Permissions insuffisantes</h6>
                <pre><code>{
  "type": "https://api.example.com/errors/forbidden",
  "title": "Forbidden",
  "status": 403,
  "detail": "You do not have permission to delete this user. Admin role required.",
  "instance": "/users/123",
  "correlation_id": "323e4567-e89b-12d3-a456-426614174000",
  "required_role": "admin",
  "current_role": "user"
}</code></pre>
              </div>
              
              <div class="error-example">
                <h6>404 Not Found - Ressource inexistante</h6>
                <pre><code>{
  "type": "https://api.example.com/errors/not-found",
  "title": "Not Found",
  "status": 404,
  "detail": "User with ID 999 does not exist.",
  "instance": "/users/999",
  "correlation_id": "423e4567-e89b-12d3-a456-426614174000"
}</code></pre>
              </div>
              
              <div class="error-example">
                <h6>422 Unprocessable Entity - Validation métier</h6>
                <pre><code>{
  "type": "https://api.example.com/errors/validation-error",
  "title": "Validation Failed",
  "status": 422,
  "detail": "One or more fields failed validation.",
  "instance": "/users",
  "correlation_id": "523e4567-e89b-12d3-a456-426614174000",
  "errors": [
    {
      "field": "email",
      "code": "email_already_exists",
      "message": "This email address is already registered."
    },
    {
      "field": "password",
      "code": "password_too_weak",
      "message": "Password must contain at least 8 characters, including uppercase, lowercase, and numbers."
    }
  ]
}</code></pre>
              </div>
              
              <div class="error-example">
                <h6>500 Internal Server Error - Erreur serveur</h6>
                <pre><code>{
  "type": "https://api.example.com/errors/internal-error",
  "title": "Internal Server Error",
  "status": 500,
  "detail": "An unexpected error occurred while processing your request. Our team has been notified.",
  "instance": "/orders/123/payment",
  "correlation_id": "623e4567-e89b-12d3-a456-426614174000"
}</code></pre>
              </div>
              
              <p><strong>Note importante :</strong> pour les 500, ne révélez JAMAIS les détails techniques (stack traces, messages d'exception bruts). Ces informations vont dans les logs serveur, pas dans la réponse au client. C'est une faille de sécurité de révéler des détails d'implémentation.</p>

              <h5 class="mt-5">Cohérence des erreurs</h5>
              <p>Toutes vos erreurs doivent suivre le même format. Si une endpoint renvoie une structure d'erreur et une autre endpoint une structure différente, c'est cauchemardesque pour le client qui doit gérer plusieurs formats.</p>
              
              <p>Créez des fonctions helper réutilisables pour générer vos erreurs.</p>
              
              <div class="code-example">
                <pre><code class="javascript">// Node.js/Express exemple
function problemDetails(type, title, status, detail, instance, extra = {}) {
  return {
    type: `https://api.example.com/errors/${type}`,
    title,
    status,
    detail,
    instance,
    correlation_id: uuidv4(),
    ...extra
  };
}

// Utilisation
res.status(422)
   .type('application/problem+json')
   .json(problemDetails(
     'validation-error',
     'Validation Failed',
     422,
     'Email already exists',
     req.path,
     { errors: [{field: 'email', message: 'Email already exists'}] }
   ));</code></pre>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-section">
          <div class="footer-logo">
            <img src="../assets/logo.jpeg" alt="YNOV Campus" class="footer-logo-img">
            <span class="footer-logo-text">Web Services</span>
          </div>
          <p class="footer-description">Jour 2 — Introduction aux API REST.</p>
        </div>
        <div class="footer-section">
          <h3>Navigation</h3>
          <ul>
            <li><a href="../index.html#programme">Programme</a></li>
            <li><a href="../index.html#projet">Projet</a></li>
            <li><a href="#atelier">Atelier J2</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h3>Ressources</h3>
          <ul>
            <li>REST Principles</li>
            <li>OpenAPI</li>
            <li>Postman</li>
          </ul>
        </div>
        <div class="footer-section">
          <h3>Contact</h3>
          <div class="contact-info">
            <p><i class="fas fa-envelope"></i> contact@ynov.com</p>
            <p><i class="fas fa-map-marker-alt"></i> Campus Ynov</p>
          </div>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2024 YNOV Campus. Tous droits réservés.</p>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
  
  <!-- highlight.js pour la coloration syntaxique -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    // Auto-détection et coloration de tous les blocs de code
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
    });
  </script>
</body>
</html>
