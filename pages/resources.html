<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ressources — Gestion des Clés API</title>
  <link rel="stylesheet" href="../styles/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
        <div class="nav-logo">
            <img src="../assets/logo.jpeg" alt="YNOV Campus" class="logo-img">
            <span class="logo-text">Web Services</span>
        </div>
        <ul class="nav-menu">
            <li class="nav-item">
                <a href="../index.html" class="nav-link">Accueil</a>
            </li>
            <li class="nav-item">
                <a href="../index.html#programme" class="nav-link">Programme</a>
            </li>
            <li class="nav-item">
                <a href="../index.html#projet" class="nav-link">Projet SmartCity</a>
            </li>
            <li class="nav-item dropdown">
                <a href="#" class="nav-link dropdown-toggle">
                    <i class="fas fa-calendar-alt"></i> Journées
                    <i class="fas fa-chevron-down"></i>
                </a>
                <div class="dropdown-menu">
                    <a href="day1.html" class="dropdown-item">Jour 1 - Théorie</a>
                    <a href="day1FilRouge.html" class="dropdown-item">Jour 1 - Fil Rouge</a>
                    <a href="day2.html" class="dropdown-item">Jour 2 - Théorie</a>
                    <a href="day2FilRouge.html" class="dropdown-item">Jour 2 - Fil Rouge</a>
                    <a href="day3.html" class="dropdown-item">Jour 3 - Théorie</a>
                    <a href="day3FilRouge.html" class="dropdown-item">Jour 3 - Fil Rouge</a>
                </div>
            </li>
            <li class="nav-item">
                <a href="resources.html" class="nav-link active">Ressources</a>
            </li>
            <li class="nav-item">
                <a href="../index.html#contact" class="nav-link">Contact</a>
            </li>
        </ul>
        <div class="hamburger">
            <span class="bar"></span>
            <span class="bar"></span>
            <span class="bar"></span>
        </div>
    </div>
</nav>

  <!-- Hero -->
  <section class="hero" style="min-height: 40vh;">
    <div class="container">
      <div class="hero-content">
        <div class="hero-text">
          <h1 class="hero-title">Ressources</h1>
          <h2 class="hero-subtitle">Gestion Sécurisée des Clés API</h2>
          <p class="hero-description">
            Guide complet pour générer, stocker et utiliser des clés API de manière sécurisée dans vos applications.
          </p>
        </div>
      </div>
      <!-- Nouvelle ressource : Validation avec Zod + Express -->
   
    </div>
  </section>

  <!-- Contenu principal -->
  <section class="programme">
    <div class="container">

      <div class="day-card expanded mb-4" id="zod-express">
        <div class="day-header">
          <span class="day-number">🧩</span>
          <span class="day-theme">Validation avec Zod + Express</span>
        </div>
        <div class="day-content">
          <p><strong>Zod</strong> permet de valider et typer vos données côté serveur. Il fonctionne en <strong>JavaScript</strong> et en <strong>TypeScript</strong>. Avec des schémas déclaratifs, vous obtenez à la fois une <em>validation runtime</em> fiable (au moment des requêtes) et des <em>types statiques</em> (autocomplétion et sécurité à la compilation) depuis une seule source de vérité. Intégré à Express via un <strong>middleware</strong>, il valide <code>body</code>, <code>query</code> et <code>params</code> et renvoie des erreurs structurées et compréhensibles.</p>

          <h4 class="mt-5"><i class="fas fa-box"></i> Installation de base</h4>
          <pre><code class="bash">npm init -y
npm install express zod
npm install -D nodemon</code></pre>

          <p><strong>Option TypeScript</strong> :</p>
          <pre><code class="bash">npm install -D typescript @types/express @types/node ts-node
npx tsc --init</code></pre>

          <h4 class="mt-5"><i class="fas fa-code"></i> Version JavaScript</h4>
          <h5>Structure de projet</h5>
          <p>Cette arborescence sépare clairement <code>schemas</code> (règles de validation), <code>middleware</code> (branchements Express) et <code>server</code> (routes). On branche ensuite les schémas via le middleware sur chaque route.</p>
          <pre><code class="text">projet/
├── src/
│   ├── schemas/
│   │   └── user.schema.js
│   ├── middleware/
│   │   └── validate.js
│   └── server.js
├── package.json
└── .gitignore</code></pre>

          <h5 class="mt-4">1) Schémas de validation — <code>src/schemas/user.schema.js</code></h5>
          <p>Les schémas décrivent la « forme » attendue des données. Ici, on valide <code>body</code>, <code>params</code> et <code>query</code>. Remarquez l'usage de <code>transform</code> et <code>pipe</code> pour convertir les query strings en nombres typés.</p>
          <pre><code class="javascript">const { z } = require('zod');

// Schéma pour créer un utilisateur
const createUserSchema = z.object({
  body: z.object({
    name: z.string({
      required_error: "Le nom est requis"
    }).min(3, "Le nom doit faire au moins 3 caractères"),

    email: z.string({
      required_error: "L'email est requis"
    }).email("Email invalide"),

    age: z.number({
      required_error: "L'âge est requis"
    }).int().positive().min(18, "Vous devez avoir au moins 18 ans"),

    password: z.string()
      .min(8, "Le mot de passe doit faire au moins 8 caractères")
      .regex(/[A-Z]/, "Doit contenir au moins une majuscule")
      .regex(/[0-9]/, "Doit contenir au moins un chiffre")
  })
});

// Schéma pour mettre à jour un utilisateur
const updateUserSchema = z.object({
  params: z.object({
    id: z.string()
  }),
  body: z.object({
    name: z.string().min(3).optional(),
    email: z.string().email().optional(),
    age: z.number().int().positive().optional()
  })
});

// Schéma pour les query params (pagination)
const getUsersSchema = z.object({
  query: z.object({
    page: z.string()
      .optional()
      .default("1")
      .transform(val => parseInt(val))
      .pipe(z.number().int().positive()),

    limit: z.string()
      .optional()
      .default("10")
      .transform(val => parseInt(val))
      .pipe(z.number().int().positive().max(100))
  })
});

module.exports = {
  createUserSchema,
  updateUserSchema,
  getUsersSchema
};</code></pre>

          <h5 class="mt-4">2) Middleware de validation — <code>src/middleware/validate.js</code></h5>
          <p>Le middleware fait le « branchement » entre Express et Zod : il appelle <code>schema.parseAsync</code> avec <code>req.body</code>, <code>req.query</code> et <code>req.params</code>. En cas d'erreur, il renvoie une réponse 400 structurée.</p>
          <pre><code class="javascript">const { ZodError } = require('zod');

const validate = (schema) => {
  return async (req, res, next) => {
    try {
      // Valide body, query et params en une seule fois
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params
      });
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({
          status: 'error',
          message: 'Erreur de validation',
          errors: error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
};

module.exports = { validate };</code></pre>

          <h5 class="mt-4">3) Serveur Express — <code>src/server.js</code></h5>
          <p>Chaque route est protégée par <code>validate(schema)</code> au plus près de la déclaration. Les schémas garantissent que les données entrantes sont correctes avant d'atteindre votre logique métier.</p>
          <pre><code class="javascript">const express = require('express');
const { validate } = require('./middleware/validate');
const { 
  createUserSchema, 
  updateUserSchema,
  getUsersSchema
} = require('./schemas/user.schema');

const app = express();
app.use(express.json());

// Base de données simulée
let users = [];
let nextId = 1;

// ✅ POST /users - Créer un utilisateur
app.post('/users', validate(createUserSchema), (req, res) => {
  const { password, ...userData } = req.body;

  const newUser = {
    id: nextId++,
    ...userData,
    createdAt: new Date().toISOString()
  };

  users.push({ ...newUser, password }); // Stocke avec password

  res.status(201).json({
    status: 'success',
    data: newUser // Renvoie sans password
  });
});

// ✅ GET /users - Liste des utilisateurs (avec pagination)
app.get('/users', validate(getUsersSchema), (req, res) => {
  const { page, limit } = req.query;

  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + limit;

  res.json({
    status: 'success',
    data: users.slice(startIndex, endIndex).map(u => {
      const { password, ...user } = u;
      return user;
    }),
    pagination: {
      page,
      limit,
      total: users.length
    }
  });
});

// ✅ GET /users/:id - Récupérer un utilisateur
app.get('/users/:id', (req, res) => {
  const user = users.find(u => u.id === Number(req.params.id));
  if (!user) {
    return res.status(404).json({ status: 'error', message: 'Utilisateur non trouvé' });
  }
  const { password, ...userData } = user;
  res.json({ status: 'success', data: userData });
});

// ✅ PUT /users/:id - Mettre à jour un utilisateur
app.put('/users/:id', validate(updateUserSchema), (req, res) => {
  const { id } = req.params;
  const userIndex = users.findIndex(u => u.id === Number(id));
  if (userIndex === -1) {
    return res.status(404).json({ status: 'error', message: 'Utilisateur non trouvé' });
  }
  users[userIndex] = {
    ...users[userIndex],
    ...req.body,
    updatedAt: new Date().toISOString()
  };
  const { password, ...userData } = users[userIndex];
  res.json({ status: 'success', data: userData });
});

// ✅ DELETE /users/:id - Supprimer un utilisateur
app.delete('/users/:id', (req, res) => {
  const { id } = req.params;
  const userIndex = users.findIndex(u => u.id === Number(id));
  if (userIndex === -1) {
    return res.status(404).json({ status: 'error', message: 'Utilisateur non trouvé' });
  }
  users.splice(userIndex, 1);
  res.json({ status: 'success', message: 'Utilisateur supprimé' });
});

// Gestion des erreurs globale
app.use((err, req, res, next) => {
  console.error('Erreur:', err);
  res.status(500).json({ status: 'error', message: 'Erreur serveur interne' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`🚀 Serveur démarré sur http://localhost:${PORT}`);
});</code></pre>

          <h5 class="mt-4">4) Scripts — <code>package.json</code></h5>
          <p>Un script <code>dev</code> pour le rechargement à chaud (nodemon) et un <code>start</code> pour la prod locale. Démarrez en développement avec <code>npm run dev</code>.</p>
          <pre><code class="json">{
  "name": "express-zod-validation",
  "version": "1.0.0",
  "scripts": {
    "dev": "nodemon src/server.js",
    "start": "node src/server.js"
  }
}</code></pre>

          <h5 class="mt-4">Démarrer le serveur</h5>
          <pre><code class="bash">npm run dev</code></pre>

          <h4 class="mt-5"><i class="fas fa-diamond"></i> Version TypeScript</h4>
          <h5>Structure de projet</h5>
          <pre><code class="text">projet/
├── src/
│   ├── schemas/
│   │   └── user.schema.ts
│   ├── middleware/
│   │   └── validate.ts
│   └── server.ts
├── package.json
├── tsconfig.json
└── .gitignore</code></pre>

          <h5 class="mt-4">1) <code>tsconfig.json</code></h5>
          <p>Configuration minimale pour compiler depuis <code>src</code> vers <code>dist</code>, avec typage strict et interop ES activée.</p>
          <pre><code class="json">{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}</code></pre>

          <h5 class="mt-4">2) Schémas — <code>src/schemas/user.schema.ts</code></h5>
          <p>Les mêmes schémas Zod servent au runtime et exposent des types <code>z.infer</code> pour bénéficier de l'autocomplétion côté TypeScript sans duplication.</p>
          <pre><code class="typescript">import { z } from 'zod';

// Schéma pour créer un utilisateur
export const createUserSchema = z.object({
  body: z.object({
    name: z.string({
      required_error: "Le nom est requis"
    }).min(3, "Le nom doit faire au moins 3 caractères"),

    email: z.string({
      required_error: "L'email est requis"
    }).email("Email invalide"),

    age: z.number({
      required_error: "L'âge est requis"
    }).int().positive().min(18, "Vous devez avoir au moins 18 ans"),

    password: z.string()
      .min(8, "Le mot de passe doit faire au moins 8 caractères")
      .regex(/[A-Z]/, "Doit contenir au moins une majuscule")
      .regex(/[0-9]/, "Doit contenir au moins un chiffre")
  })
});

// Schéma pour mettre à jour un utilisateur
export const updateUserSchema = z.object({
  params: z.object({
    id: z.string()
  }),
  body: z.object({
    name: z.string().min(3).optional(),
    email: z.string().email().optional(),
    age: z.number().int().positive().optional()
  })
});

// Schéma pour les query params
export const getUsersSchema = z.object({
  query: z.object({
    page: z.string()
      .optional()
      .default("1")
      .transform(val => parseInt(val))
      .pipe(z.number().int().positive()),

    limit: z.string()
      .optional()
      .default("10")
      .transform(val => parseInt(val))
      .pipe(z.number().int().positive().max(100))
  })
});

// 🎯 Types TypeScript inférés automatiquement
export type CreateUserInput = z.infer<typeof createUserSchema>['body'];
export type UpdateUserInput = z.infer<typeof updateUserSchema>['body'];
export type GetUsersQuery = z.infer<typeof getUsersSchema>['query'];</code></pre>

          <h5 class="mt-4">3) Middleware — <code>src/middleware/validate.ts</code></h5>
          <p>Le middleware est typé avec les interfaces Express. On conserve le même flux : parse → next() ou réponse 400 avec liste d'erreurs.</p>
          <pre><code class="typescript">import { Request, Response, NextFunction } from 'express';
import { AnyZodObject, ZodError } from 'zod';

export const validate = (schema: AnyZodObject) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params
      });
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({
          status: 'error',
          message: 'Erreur de validation',
          errors: error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
};</code></pre>

          <h5 class="mt-4">4) Serveur — <code>src/server.ts</code></h5>
          <p>On illustre l'usage des types inférés (<code>CreateUserInput</code>) pour typer <code>req.body</code> et sécuriser la manipulation des données dans les handlers.</p>
          <pre><code class="typescript">import express, { Request, Response, NextFunction } from 'express';
import { validate } from './middleware/validate';
import { 
  createUserSchema, 
  updateUserSchema,
  getUsersSchema,
  CreateUserInput 
} from './schemas/user.schema';

const app = express();
app.use(express.json());

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  password: string;
  createdAt: string;
  updatedAt?: string;
}

let users: User[] = [];
let nextId = 1;

// ✅ POST /users
app.post(
  '/users',
  validate(createUserSchema),
  (req: Request<{}, {}, CreateUserInput>, res: Response) => {
    const { password, ...userData } = req.body;
    const newUser: User = {
      id: nextId++,
      ...userData,
      password,
      createdAt: new Date().toISOString()
    };
    users.push(newUser);
    const { password: _, ...userResponse } = newUser;
    res.status(201).json({ status: 'success', data: userResponse });
  }
);

// ✅ GET /users
app.get('/users', validate(getUsersSchema), (req: Request, res: Response) => {
  const { page = 1, limit = 10 } = req.query as any;
  const startIndex = (Number(page) - 1) * Number(limit);
  const endIndex = startIndex + Number(limit);
  const usersWithoutPassword = users.slice(startIndex, endIndex).map(u => {
    const { password, ...user } = u; return user;
  });
  res.json({
    status: 'success',
    data: usersWithoutPassword,
    pagination: { page: Number(page), limit: Number(limit), total: users.length }
  });
});

// ✅ GET /users/:id
app.get('/users/:id', (req: Request, res: Response) => {
  const user = users.find(u => u.id === Number(req.params.id));
  if (!user) return res.status(404).json({ status: 'error', message: 'Utilisateur non trouvé' });
  const { password, ...userData } = user;
  res.json({ status: 'success', data: userData });
});

// ✅ PUT /users/:id
app.put('/users/:id', validate(updateUserSchema), (req: Request, res: Response) => {
  const { id } = req.params;
  const userIndex = users.findIndex(u => u.id === Number(id));
  if (userIndex === -1) return res.status(404).json({ status: 'error', message: 'Utilisateur non trouvé' });
  users[userIndex] = { ...users[userIndex], ...req.body, updatedAt: new Date().toISOString() };
  const { password, ...userData } = users[userIndex];
  res.json({ status: 'success', data: userData });
});

// ✅ DELETE /users/:id
app.delete('/users/:id', (req: Request, res: Response) => {
  const { id } = req.params;
  const userIndex = users.findIndex(u => u.id === Number(id));
  if (userIndex === -1) return res.status(404).json({ status: 'error', message: 'Utilisateur non trouvé' });
  users.splice(userIndex, 1);
  res.json({ status: 'success', message: 'Utilisateur supprimé' });
});

// Gestion des erreurs
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error('Erreur:', err);
  res.status(500).json({ status: 'error', message: 'Erreur serveur interne' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`🚀 Serveur démarré sur http://localhost:${PORT}`);
});</code></pre>

          <h5 class="mt-4">5) Scripts — <code>package.json</code></h5>
          <p>En TS, on démarre en dev via <code>ts-node</code>, on build avec <code>tsc</code>, puis on lance le JavaScript généré dans <code>dist</code>.</p>
          <pre><code class="json">{
  "scripts": {
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  }
}</code></pre>

          <h4 class="mt-5"><i class="fas fa-vial"></i> Tests avec cURL</h4>
          <p>Ces appels montrent le comportement attendu : 201 en création valide, 400 avec liste d'erreurs sinon, pagination correcte pour la liste.</p>
          <h5>Créer un utilisateur (valide)</h5>
          <pre><code class="bash">curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alice Dubois",
    "email": "alice@example.com",
    "age": 25,
    "password": "Password123"
  }'</code></pre>

          <h5>Créer un utilisateur (invalide)</h5>
          <pre><code class="bash">curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Al",
    "email": "invalid-email",
    "age": 15,
    "password": "weak"
  }'</code></pre>

          <h5>Liste (pagination)</h5>
          <pre><code class="bash">curl "http://localhost:3000/users?page=1&limit=10"</code></pre>

          <h5>Récupérer / Mettre à jour / Supprimer</h5>
          <pre><code class="bash">curl http://localhost:3000/users/1
curl -X PUT http://localhost:3000/users/1 -H "Content-Type: application/json" -d '{"name":"Alice Martin","age":26}'
curl -X DELETE http://localhost:3000/users/1</code></pre>

          <h4 class="mt-5"><i class="fas fa-lightbulb"></i> Bonus : validations avancées</h4>
          <pre><code class="javascript">// Email personnalisé
email: z.string().email().endsWith('@school.com')

// Enum
role: z.enum(['admin', 'user', 'guest'])

// Date (ISO)
birthDate: z.string().datetime()

// Validation conditionnelle
z.object({
  type: z.enum(['student', 'teacher']),
  studentId: z.string().optional()
}).refine(data => {
  if (data.type === 'student') {
    return !!data.studentId;
  }
  return true;
}, {
  message: "studentId requis pour les étudiants",
  path: ['studentId']
})</code></pre>
        </div>
      </div>


      <div class="day-card expanded mb-4">
        <div class="day-header">
          <span class="day-number">🔑</span>
          <span class="day-theme">Gestion des Clés API</span>
        </div>
        <div class="day-content">
          <!-- Génération -->
          <h4 class="mt-5"><i class="fas fa-key"></i> Génération de la clé API</h4>
          <h5>Caractéristiques d'une bonne clé API</h5>
          <ul>
            <li><strong>Longueur minimale :</strong> 32 caractères</li>
            <li><strong>Caractères aléatoires :</strong> Utiliser des caractères alphanumériques + symboles</li>
            <li><strong>Imprévisible :</strong> Générée avec un générateur cryptographiquement sécurisé</li>
          </ul>

          <h5 class="mt-4">Exemple de génération (Node.js)</h5>
          <pre><code class="javascript">const crypto = require('crypto');

function generateApiKey() {
  return crypto.randomBytes(32).toString('hex');
  // Génère une clé de 64 caractères hexadécimaux
}</code></pre>

          <h5 class="mt-4">Format recommandé</h5>
          <p><strong>Préfixe identifiable + clé aléatoire</strong></p>
          <p>Exemple : <code>sk_live_a3f8d9c2b1e4f5a6d7c8b9e0f1a2b3c4</code></p>

          <!-- Section 2: Stockage -->
          <h4 class="mt-5"><i class="fas fa-database"></i> Stockage sécurisé</h4>
          <div class="highlight-box" style="background: #fee; border-left: 4px solid #f00;">
            <h6>⚠️ Ne JAMAIS stocker la clé en clair</h6>
          </div>

          <h5 class="mt-4">Mauvaise pratique ❌</h5>
          <pre><code class="sql">INSERT INTO api_keys (key, user_id) 
VALUES ('sk_live_abc123...', 1);</code></pre>

          <h5 class="mt-4">Bonne pratique ✅</h5>
          <pre><code class="javascript">const crypto = require('crypto');

function hashApiKey(apiKey) {
  return crypto
    .createHash('sha256')
    .update(apiKey)
    .digest('hex');
}

// Stockage
const hashedKey = hashApiKey(apiKey);
// Stocker hashedKey dans la base de données</code></pre>

          <h5 class="mt-4">Structure de table recommandée</h5>
          <pre><code class="sql">CREATE TABLE api_keys (
  id SERIAL PRIMARY KEY,
  key_hash VARCHAR(64) NOT NULL UNIQUE,
  user_id INTEGER NOT NULL,
  name VARCHAR(100),
  created_at TIMESTAMP DEFAULT NOW(),
  last_used_at TIMESTAMP,
  expires_at TIMESTAMP,
  is_active BOOLEAN DEFAULT true
);</code></pre>

          <!-- Section 3: Mise à disposition -->
          <h4 class="mt-5"><i class="fas fa-user-check"></i> Mise à disposition au client</h4>
          <h5>Affichage unique lors de la création</h5>
          <div class="highlight-box" style="background: #efe; border-left: 4px solid #0a0;">
            <h6>✅ Clé API créée avec succès !</h6>
            <p><code style="font-family: monospace; background: #f5f5f5; padding: 0.5rem;">sk_live_a3f8d9c2b1e4f5a6d7c8b9e0f1a2b3c4</code></p>
            <h6>⚠️ IMPORTANT :</h6>
            <ul>
              <li>Copiez cette clé maintenant</li>
              <li>Elle ne sera plus affichée</li>
              <li>Conservez-la en lieu sûr</li>
            </ul>
          </div>

          <h5 class="mt-4">API de création</h5>
          <pre><code class="javascript">// POST /api/keys
{
  "name": "Clé de production",
  "expires_in_days": 365
}

// Réponse
{
  "api_key": "sk_live_a3f8d9c2b1e4f5a6d7c8b9e0f1a2b3c4",
  "name": "Clé de production",
  "created_at": "2025-10-28T10:30:00Z",
  "expires_at": "2026-10-28T10:30:00Z",
  "message": "Sauvegardez cette clé, elle ne sera plus affichée"
}</code></pre>

          <!-- Section 4: Vérification -->
          <h4 class="mt-5"><i class="fas fa-shield-alt"></i> Vérification de la clé</h4>
          <h5>Middleware de vérification (Express.js)</h5>
          <pre><code class="javascript">async function verifyApiKey(req, res, next) {
  // 1. Extraire la clé du header
  const apiKey = req.headers['x-api-key'] || 
                 req.headers['authorization']?.replace('Bearer ', '');
  
  if (!apiKey) {
    return res.status(401).json({ 
      error: 'Clé API manquante' 
    });
  }

  // 2. Hasher la clé reçue
  const hashedKey = hashApiKey(apiKey);

  // 3. Rechercher dans la base de données
  const key = await db.query(
    `SELECT * FROM api_keys 
     WHERE key_hash = $1 
     AND is_active = true 
     AND (expires_at IS NULL OR expires_at > NOW())`,
    [hashedKey]
  );

  if (!key) {
    return res.status(401).json({ 
      error: 'Clé API invalide ou expirée' 
    });
  }

  // 4. Mettre à jour la dernière utilisation
  await db.query(
    'UPDATE api_keys SET last_used_at = NOW() WHERE id = $1',
    [key.id]
  );

  // 5. Ajouter l'utilisateur au contexte
  req.user = key.user_id;
  next();
}

// Utilisation
app.get('/api/data', verifyApiKey, (req, res) => {
  // Route protégée
});</code></pre>

          <!-- Section 5: Bonnes pratiques -->
          <h4 class="mt-5"><i class="fas fa-lock"></i> Bonnes pratiques de sécurité</h4>
          <h5>Limitation de débit (Rate Limiting)</h5>
          <pre><code class="javascript">const rateLimit = require('express-rate-limit');

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requêtes max
  keyGenerator: (req) => req.user, // Par utilisateur
  message: 'Trop de requêtes, réessayez plus tard'
});

app.use('/api/', apiLimiter);</code></pre>

          <h5 class="mt-4">Rotation des clés</h5>
          <ul>
            <li>Permettre aux clients de générer de nouvelles clés</li>
            <li>Période de transition avec deux clés actives</li>
            <li>Notification avant expiration</li>
          </ul>

          <h5 class="mt-4">Surveillance</h5>
          <ul>
            <li>Logger les tentatives d'accès échouées</li>
            <li>Alerter sur les comportements suspects</li>
            <li>Révoquer automatiquement après X échecs consécutifs</li>
          </ul>

          <!-- Section 6: Documentation -->
          <h4 class="mt-5"><i class="fas fa-book"></i> Documentation pour les clients</h4>
          <h5>Comment utiliser la clé API</h5>
          
          <h5 class="mt-4">En-tête HTTP recommandé</h5>
          <pre><code class="bash">curl -H "X-API-Key: sk_live_votre_cle_ici" \
     https://api.votreservice.com/data</code></pre>

          <p>Ou avec Bearer token</p>
          <pre><code class="bash">curl -H "Authorization: Bearer sk_live_votre_cle_ici" \
     https://api.votreservice.com/data</code></pre>

          <h5 class="mt-4">Codes d'erreur</h5>
          <ul>
            <li><strong>401 :</strong> Clé manquante ou invalide</li>
            <li><strong>403 :</strong> Clé valide mais accès refusé à cette ressource</li>
            <li><strong>429 :</strong> Limite de débit dépassée</li>
          </ul>

          <!-- Section 7: Gestion côté client -->
          <h4 class="mt-5"><i class="fas fa-list"></i> Gestion des clés côté client</h4>
          <h5>Liste des clés actives</h5>
          <pre><code class="text">GET /api/keys

Réponse :
[
  {
    "id": 1,
    "name": "Clé de production",
    "prefix": "sk_live_a3f8",
    "created_at": "2025-10-28T10:30:00Z",
    "last_used_at": "2025-10-28T15:20:00Z",
    "expires_at": "2026-10-28T10:30:00Z"
  }
]</code></pre>

          <h5 class="mt-4">Révocation d'une clé</h5>
          <pre><code class="text">DELETE /api/keys/:id

Réponse :
{
  "message": "Clé révoquée avec succès"
}</code></pre>

          <!-- Checklist -->
          <h4 class="mt-5"><i class="fas fa-check-square"></i> Checklist de sécurité</h4>
          <div class="highlight-box">
            <ul style="list-style: none; padding-left: 0;">
              <li>✓ Les clés sont générées de manière cryptographiquement sécurisée</li>
              <li>✓ Les clés sont hashées avant stockage (jamais en clair)</li>
              <li>✓ La clé n'est affichée qu'une seule fois lors de la création</li>
              <li>✓ Limitation du nombre de requêtes par clé</li>
              <li>✓ Logging des accès et tentatives échouées</li>
              <li>✓ Possibilité de révoquer une clé</li>
              <li>✓ Expiration automatique des clés</li>
              <li>✓ Communication HTTPS uniquement</li>
              <li>✓ Documentation claire pour les développeurs</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Nouvelle ressource : Déploiement sur Render -->
      <div class="day-card expanded mb-4">
        <div class="day-header">
          <span class="day-number">🚀</span>
          <span class="day-theme">Déploiement sur Render</span>
        </div>
        <div class="day-content">
          <!-- Introduction -->
          <h4 class="mt-5"><i class="fas fa-cloud"></i> Qu'est-ce que Render ?</h4>
          <p>Render est une plateforme de cloud hosting très populaire (dans la même famille que Vercel, Railway, ou Fly.io) qui permet de déployer gratuitement de petites APIs Node.js / Express.</p>

          <div class="highlight-box" style="background: #e8f4fd; border-left: 4px solid #0066cc;">
            <h6>📊 Fonctionnalités principales</h6>
            <ul>
              <li>✅ Déploiement automatique depuis GitHub/GitLab</li>
              <li>✅ Hébergement gratuit avec Free Tier</li>
              <li>✅ PostgreSQL gratuit inclus</li>
              <li>✅ HTTPS automatique avec URL publique</li>
              <li>⚡ Sleep mode après 15 minutes d'inactivité (limite du gratuit)</li>
            </ul>
          </div>

          <!-- Structure de fichiers -->
          <h4 class="mt-5"><i class="fas fa-folder"></i> Structure de base d'une API pour Render</h4>
          
          <h5 class="mt-4">1. Fichier server.js</h5>
          <pre><code class="javascript">import express from "express";
const app = express();

app.use(express.json());

app.get("/", (req, res) => {
  res.json({ message: "API en ligne via Render 🚀" });
});

app.get("/api/status", (req, res) => {
  res.json({ 
    status: "ok", 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || "development"
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Serveur démarré sur le port ${PORT}`);
});</code></pre>

          <h5 class="mt-4">2. Fichier package.json</h5>
          <pre><code class="json">{
  "name": "smartcity-api",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "dependencies": {
    "express": "^4.19.2",
    "dotenv": "^16.3.1"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}</code></pre>

          <h5 class="mt-4">3. Fichier .env (optionnel, pour variables locales)</h5>
          <pre><code class="text">PORT=3000
NODE_ENV=development
DATABASE_URL=postgresql://user:password@localhost:5432/smartcity</code></pre>

          <!-- Guide de déploiement -->
          <h4 class="mt-5"><i class="fas fa-rocket"></i> Guide de déploiement étape par étape</h4>

          <h5 class="mt-4">Étape 1 : Préparer le projet</h5>
          <ol>
            <li>Créez votre API Node.js/Express localement</li>
            <li>Assurez-vous que le fichier <code>package.json</code> contient un script <code>"start"</code></li>
            <li>Testez que l'API fonctionne en local avec <code>npm start</code></li>
          </ol>

          <h5 class="mt-4">Étape 2 : Pousser sur GitHub</h5>
          <pre><code class="bash"># Initialiser le repo si nécessaire
git init
git add .
git commit -m "Initial commit: API SmartCity"

# Créer un repo sur GitHub, puis :
git remote add origin https://github.com/votre-username/smartcity-api.git
git branch -M main
git push -u origin main</code></pre>

          <h5 class="mt-4">Étape 3 : Déployer sur Render</h5>
          <ol>
            <li>Allez sur <a href="https://render.com" target="_blank">https://render.com</a></li>
            <li>Créez un compte (gratuit avec GitHub)</li>
            <li>Cliquez sur <strong>"New"</strong> → <strong>"Web Service"</strong></li>
            <li>Connectez votre dépôt GitHub et sélectionnez le projet</li>
            <li>Configurez les paramètres :
              <ul>
                <li><strong>Name :</strong> smartcity-api (ou votre nom)</li>
                <li><strong>Environment :</strong> Node</li>
                <li><strong>Build Command :</strong> <code>npm install</code></li>
                <li><strong>Start Command :</strong> <code>npm start</code></li>
                <li><strong>Plan :</strong> Free (pour commencer)</li>
              </ul>
            </li>
            <li>Cliquez sur <strong>"Create Web Service"</strong></li>
          </ol>

          <h5 class="mt-4">Étape 4 : Configuration des variables d'environnement</h5>
          <p>Dans les paramètres de votre service sur Render, allez dans <strong>"Environment"</strong> et ajoutez :</p>
          <ul>
            <li><code>NODE_ENV=production</code></li>
            <li><code>DATABASE_URL</code> (si vous utilisez PostgreSQL)</li>
            <li>Toutes autres variables nécessaires à votre API</li>
          </ul>

          <h5 class="mt-4">Étape 5 : Déploiement automatique</h5>
          <p>Dès que vous poussez du code sur GitHub (branche <code>main</code>), Render redéploie automatiquement votre API !</p>

          <!-- Exemple complet -->
          <h4 class="mt-5"><i class="fas fa-code"></i> Exemple complet : API avec route /events</h4>
          <pre><code class="javascript">import express from "express";
import cors from "cors";

const app = express();
app.use(cors());
app.use(express.json());

// Route de test
app.get("/", (req, res) => {
  res.json({ 
    message: "API SmartCity déployée sur Render 🚀",
    version: "1.0.0"
  });
});

// Route métier
app.get("/api/events", (req, res) => {
  res.json({
    data: [
      { id: 1, title: "Concert Jazz", date: "2025-07-15" },
      { id: 2, title: "Exposition Art", date: "2025-08-20" }
    ]
  });
});

// Gestion des erreurs 404
app.use((req, res) => {
  res.status(404).json({ error: "Route not found" });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`✅ API démarrée sur le port ${PORT}`);
  console.log(`🌐 URL publique: ${process.env.RENDER_EXTERNAL_URL || 'local'}`);
});</code></pre>

          <!-- Base de données PostgreSQL -->
          <h4 class="mt-5"><i class="fas fa-database"></i> Ajouter une base de données PostgreSQL</h4>
          <ol>
            <li>Dans Render, cliquez sur <strong>"New"</strong> → <strong>"PostgreSQL"</strong></li>
            <li>Choisissez le <strong>Plan Free</strong></li>
            <li>Notez la <code>DATABASE_URL</code> générée automatiquement</li>
            <li>Dans votre Web Service, ajoutez cette URL comme variable d'environnement</li>
            <li>Installez <code>pg</code> : <code>npm install pg</code></li>
          </ol>

          <h5 class="mt-4">Exemple de connexion à la DB</h5>
          <pre><code class="javascript">import pg from 'pg';
const { Pool } = pg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Test de connexion
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('❌ Erreur de connexion à la DB:', err);
  } else {
    console.log('✅ Connecté à PostgreSQL:', res.rows[0].now);
  }
});</code></pre>

          <!-- Limitations et bonnes pratiques -->
          <h4 class="mt-5"><i class="fas fa-exclamation-triangle"></i> Limitations du plan gratuit</h4>
          <div class="highlight-box" style="background: #fff4e6; border-left: 4px solid #ff9800;">
            <ul>
              <li>⚠️ <strong>Sleep mode :</strong> Le service s'endort après ~15 minutes d'inactivité (premier appel lent pour réveiller)</li>
              <li>⚠️ <strong>Ressources limitées :</strong> CPU et mémoire faibles (suffisant pour les cours/démos)</li>
              <li>⚠️ <strong>Pas de domaine custom :</strong> URL en <code>.onrender.com</code> uniquement</li>
              <li>⚠️ <strong>Limites de bande passante :</strong> Suffisant pour le développement et tests</li>
            </ul>
          </div>

          <h4 class="mt-5"><i class="fas fa-check-circle"></i> Checklist de déploiement</h4>
          <div class="highlight-box">
            <ul style="list-style: none; padding-left: 0;">
              <li>✓ Le fichier <code>package.json</code> existe avec le script <code>"start"</code></li>
              <li>✓ Le fichier d'entrée principal existe (ex: <code>server.js</code>)</li>
              <li>✓ L'API écoute sur le port défini par <code>process.env.PORT</code></li>
              <li>✓ Le projet est poussé sur GitHub</li>
              <li>✓ Les variables d'environnement sont configurées sur Render</li>
              <li>✓ Les dépendances sont listées dans <code>package.json</code></li>
              <li>✓ Les CORS sont configurés si l'API est appelée depuis un frontend</li>
              <li>✓ La gestion d'erreurs 404 est implémentée</li>
            </ul>
          </div>

          <!-- URLs et exemples -->
          <h4 class="mt-5"><i class="fas fa-link"></i> Résultat attendu</h4>
          <p>Après le déploiement, vous obtenez une URL publique HTTPS automatiquement :</p>
          <div class="highlight-box" style="background: #e8f5e9; border-left: 4px solid #4caf50;">
            <h6>✅ Votre API est accessible à :</h6>
            <p><code style="font-family: monospace; background: white; padding: 0.5rem; display: block; margin-top: 0.5rem;">https://smartcity-api.onrender.com</code></p>
            <p>Vous pouvez tester immédiatement :</p>
            <pre><code class="bash">curl https://smartcity-api.onrender.com/api/events</code></pre>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-section">
          <div class="footer-logo">
            <img src="../assets/logo.jpeg" alt="YNOV Campus" class="footer-logo-img">
            <span class="footer-logo-text">Web Services</span>
          </div>
          <p class="footer-description">Ressources — Clés API & Déploiement.</p>
        </div>
        <div class="footer-section">
          <h3>Navigation</h3>
          <ul>
            <li><a href="../index.html#programme">Programme</a></li>
            <li><a href="../index.html#projet">Projet</a></li>
            <li><a href="resources.html">Ressources</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2024 YNOV Campus. Tous droits réservés.</p>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      hljs.highlightAll();
    });
  </script>
</body>
</html>

